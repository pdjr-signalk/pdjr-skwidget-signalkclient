# signalk-client

Library providing a web-client application interface to SignalK

signalk-client implements the SignalkClient class which supports WebSocket
connection to a Signal K server and provides methods for programmatic and
event driven access to the server's data paths.

Applications are encourage to extend the SignalkClient class using the
following simple pattern:
```
super(host, port).waitForConnection().then(_ => {
   // do application specific stuff
});

## Creating a connection object

### SignalkClient(host, port[, options])

Returns a new SignalkClient object, associating it with the Signal K server
identified by _host_:_port_.

The connection is attempted asynchronously and the constructor will inevitably
return before the putative connection is in a usable state. Users should use
the waitForConnection method to manage this eventuality.

The _options_ structure can be used to supply some additional configuration
properties:

__debug__: boolean value switching trace messaging on and off (default);

 *
 * waitForConnection([millis])
 *
 * Returns a promise which will resolve when a connection is established. The
 * frequency at which the connection is polled defaults to 500 milliseconds,
 * but this can be adjusted by supplying the optional <millis> argument.
 *
 * EVENT DRIVEN DATA ACCESS
 *
 * The event driven methods allow the host application to register an arbitrary
 * number of callback functions which will be invoked each time a value on a
 * defined Signal K path is updated.
 *
 * registerCallback(path, callback[, filter])
 *
 * Registers <callback> for invocation when the data value on <path> changes.
 * For convenience, values generated by the Signal K server are automatically
 * processed before being passed to <callback> (see below). If a <filter>
 * function is supplied then the host application can override most of this
 * automatic processing.
 *
 * The value returned from Signal K is processed in the following way.
 *
 * 1. The value is parsed into a JSON value.
 * 2. If <filter> is defined, then the JSON value is processed by <filter>
 *    and the result passed directly to <callback>.
 * 3. Otherwise, if the JSON value is an object AND it contains a "value"
 *    attribute then the value attribute is passed to <callback>.
 * 4. Otherwise, the JSON value is passed to <callback>.
 *
 * registerInterpolation(path, element[, filter[, callbackFilter]])
 *
 * Registers a built-in callback function (using registerCallback) which will
 * attempt to interpolate updates on the specified Signal K <path> directly
 * into the DOM as the HTML content of <element>. <filter>  can be used to
 * process the value before interpolation and <callbackFilter> can be used
 * to pass a filter to registerCallback if so required.
 *
 * PROGRAMMATIC DATA ACCESS
 *
 * The programmatic methods recover a Signal K data value by making a single
 * synchronous or asynchronous call to the Signal K server.
 *
 * getValue(path[, callback[, filter]])
 *
 * Recovers the current value associated with server <path>.  If <filter> is
 * specified the recovered value is processed by the supplied function. If
 * <callback> is undefined or null, then getValue makes a synchronous call to
 * the server and the recovered value is returned as the function result. If a
 * <callback> is supplied, then an asynchronous call is made to the server and
 * the return value of getValue is undefined.
 * 
 * interpolateValue(path, element[, filter[, getFilter]]);
 *
 * A convenience function which interpolates a <path> value recovered using
 * getFilter into the DOM as the HTML content of <element>. The recovered
 * value can be processed using a <filter> function and processing within
 * getValue can be implemented by specifying <getFilter>.
 *
 */
